# 对象的组合

### 1，设计线程安全的类

  	在线程安全的程序中，虽然可以将程序的所有状态都保存在公有的静态域中，但与那些将状态封装起来的程序相比，这些程序的线程安全性更难以得到验证，并且在修改时也更难以始终确保其线程安全性。通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。

​	在设计线程安全类的过程中，需要包含以下三个基本要素：

- 找出构成对象状态的所有变量

- 找出约束状态变量的不变形条件

- 建立对象状态的并发访问管理策略

​       要分析对象的状态，首先从对象的域开始。如果对象中所有的域都是基本类型的变量，那么这些域将构成对象的全部状态。如果对象的域中引用了其他对象，那么该对象的状态将包含引用对象的域。例如，LinkedList的状态就包括该链表中所有节点对象的域。

​	同步策略定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写为正式文档。

#### 1.1 收集同步需求

​	要确保类的线程安全性，就需要确保它的不变形条件不会在并发访问的情况下被破坏，这就需要对其状态进行推断。对象与变量都有一个状态空间，即所有可能的取值。状态空间越小，就越容易判断线程的状态。final类型的域使用的越多，就越能简化对象可能状态的分析过程。

​	如果在一个不变形条件中包含多个变量，那么在执行任何访问相关变量的操作时，必须持有保护这些变量的锁。

#### 1.2 依赖状态的操作

​	类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件。例如，不能从空队列中移除一个元素，在删除元素前，队列必须处于“非空的”状态。如果在某个操作中包含有基于状态的先验条件，那么这个操作就称为依赖状态的操作。

​	在单线程程序中，如果有个操作无法满足先验条件，那么就只能失败。但在并发程序中，先验条件可能会由于其他线程执行的操作而变成真。在并发程序中要一直等到先验条件为真，然后再执行该操作。

​	在Java中，等待某个条件为真的各种内置机制（包括等待和通知等机制）都与内置加锁机制紧密关联，要想正确地使用它们并不容易。要想实现某个等待先验条件为真时才执行的操作，一种更简单的方法是通过现有库中的类（例如阻塞队列或信号量）来实现依赖状态的行为。

#### 1.3 状态的所有权



###  2 实例封闭

​	如果某对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用。你可以确保该对象只能由单个线程访问（线程封闭），或者通过一个锁来保护该对象的所有访问。

​	封装简化了线程安全类的实现过程，它提供了一种实例封闭机制，通常也简称为“封闭”。当一个对象被封闭到另一个对象中时，能够访问被封装对象的所有代码路径都是已知的。与对象可以由整个程序访问的情况相比，更易于对代码进行分析。通过将封闭机制与合适的加锁策略结合起来，可以确保以现场安全的方式来使用非线程安全的对象。

​	将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

​	被封闭对象一定不能超出他们既定的作用域。



## notify(),notifyAll(),wait(),sleep()

线程同步方法，notify，notifyAll，wait 需要同一个锁，需要显式捕获InterruptException，这几个都是Object方法；

wait是会释放当前的锁，然后让出CPU，线程进入等待状态；只有当notify/notifyAll方法被执行时，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完sychronized代码块的代码或者中途遇到wait（），再次释放锁；也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程 ；

notify唤醒当前线程，将当前线程移至entrySet，同时状态为：**RUNNABLE**



java thread的运行周期中, 有几种状态, 在 java.lang.Thread.State 中有详细定义和说明:

**NEW** 状态是指线程刚创建, 尚未启动

**RUNNABLE** 状态是线程正在正常运行中, 当然可能会有某种耗时计算/IO等待的操作/CPU时间片切换等, 这个状态下发生的等待一般是其他系统资源, 而不是锁, Sleep等

**BLOCKED**  这个状态下, 是在多个线程有同步操作的场景, 比如正在等待另一个线程的synchronized 块的执行释放, 或者可重入的 synchronized块里别人调用wait() 方法, 也就是这里是线程在等待进入临界区

**WAITING**  这个状态下是指线程拥有了某个锁之后, 调用了他的wait方法, 等待其他线程/锁拥有者调用 notify / notifyAll 一遍该线程可以继续下一步操作, 这里要区分 BLOCKED 和 WATING 的区别, 一个是在临界点外面等待进入, 一个是在理解点里面wait等待别人notify, 线程调用了join方法 join了另外的线程的时候, 也会进入WAITING状态, 等待被他join的线程执行结束

**TIMED_WAITING**  这个状态就是有限的(时间限制)的WAITING, 一般出现在调用wait(long), join(long)等情况下, 另外一个线程sleep后, 也会进入TIMED_WAITING状态

**TERMINATED** 这个状态下表示 该线程的run方法已经执行完毕了, 基本上就等于死亡了(当时如果线程被持久持有, 可能不会被回收)





## 类库线程池

### 1，newFixedThreadPool

固定长度线程池，每提交一个任务创建一个新的线程，直到达到线程池的最大数量；线程规模将不再变化，线程死掉后会进行补充。

### 2，newCachedThreadPool

创建一个可换成的线程池，如果线程池的规模超过了处理需求时，则收回空闲线程；当需求增加时，可以添加新的线程；线程池的规模不受限制。

### 3，newSignleThreadExecutor

是一个单线程的Executor，创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来代替。

### 4，newScheduledThreadPool

创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。



### 









